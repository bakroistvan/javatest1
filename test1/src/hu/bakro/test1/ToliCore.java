package hu.bakro.test1;

import java.io.IOException;

//
//
//  Generated by StarUML(tm) Java Add-In
//
//  @ Project : TiliToli
//  @ File Name : ToliCore.java
//  @ Date : 2014.05.04.
//  @ Author : Bakró Nagy István
//
//

public class ToliCore {
	protected final int _xNum;
	protected final int _yNum;
	private boolean _inProgress = false;
	protected Item[][] _table;

	/**
	 * A jatekmag peldanyositasa xNum,yNum meretu tablaval. A konstruktor a tablat az eredeti helyevel inicializalja az elemeket.
	 * @param xNum Tabla sorainak szama
	 * @param yNum Tabla oszlopainak szama
	**/
	public ToliCore(int xNum, int yNum) {
		_xNum = xNum;
		_yNum = yNum;

		_table = new Item[_xNum][_yNum];
		// elemek feltoltese az eredeti koordinatakkal
		for (int xx = 0; xx < _xNum; xx++) {
			for (int yy = 0; yy < _yNum; yy++) {
				if (xx == _xNum - 1 && yy == _yNum - 1) {
					_table[xx][yy] = null;
				} else {
					_table[xx][yy] = new Item(xx, yy);
				}

			}
		}

	}

	/**
	 * Adott x,y indexu elem lekerese
	 * 
	 * @param    x	Lekerendo elem x indexe
	 * @param    y	Lekerendo elem y indexe
	 **/
	public Item getItem(int x, int y) {
		return _table[x][y];
	}
	
	/**
	 * Adott x,y indexu elem peldanyositasa a valX,valY ertekkel lekerese
	 * 
	 * @param    x	Beallitando elem x indexe
	 * @param    y	Beallitando elem y indexe
	 * @param    valY	Az elem eredeti x indexe
	 * @param    valX	Az elem eredeti x indexe
	 **/
	public void setItemXY(int x, int y, int valX, int valY) {
		_table[x][y] = new Item(valX, valY);
	}
	
	/**
	 * Adott x,y indexu elem torlese (null)
	 * 
	 * @param    x	Torlendo elem x indexe
	 * @param    y	Torlendo elem y indexe
	 **/
	public void clearItemXY(int x, int y) {
		_table[x][y] = null;
	}

	/**
	 * A jatek folyamatanak lekerdezese
	 * 
	 **/
	public boolean isInProgress() {
		return _inProgress;
	}

	/**
	 * 100 veletlen lepeses keveres, de kirakott tabla nem lehetseges
	 * Eloszor megkeresi az ures mezot, amit 100 veletlen, de szabalyos lepessel mozgat
	 **/
	public void shuffle() {
		_inProgress = true;
		// ures mezo megtalalasa
		int u_x = 0, u_y = 0;
		for (int xx = 0; xx < _xNum; xx++) {
			for (int yy = 0; yy < _yNum; yy++) {
				if (_table[xx][yy] == null) {
					u_x = xx;
					u_y = yy;
				}
			}
		}
		do {
			// ures mezo mozgatasa veletlen iranyba
			for (int tt = 0; tt < 100 * _xNum * _yNum; tt++) {
				/*
				 * 0 -> fel 1 -> le 2 -> balra 3 -> jobbra
				 */
				int rnd = (int) Math.floor(4 * Math.random());
				try {
					switch (rnd) {
					case 0:
						move(u_x - 1, u_y);
						u_x--;
						break;
					case 1:
						move(u_x + 1, u_y);
						u_x++;
						break;
					case 2:
						move(u_x, u_y - 1);
						u_y--;
						break;
					case 3:
						move(u_x, u_y + 1);
						u_y++;
						break;
					}
				} catch (ArrayIndexOutOfBoundsException e) {
					// tablan kivuli index ex. elkapasa
				}
			}
		} while (this.isGameOver());
		_inProgress = true;
	}

	/**
	 * Adott x es y indexu elemet mozdit, ha tud (true), ha nem akkor false-al
	 * ter vissza.
	 * 
	 * @param x Mozditando elem x indexe
	 * @param y Mozditando elem y indexe
	 **/
	public boolean move(int x, int y) throws ArrayIndexOutOfBoundsException {
		// elem indexe a tablan kivulre esik
		if (x < 0 || y < 0 || x >= _xNum || y > _yNum) {
			throw new ArrayIndexOutOfBoundsException("x = "
					+ Integer.toString(x) + "y = " + Integer.toString(y));
		}
		// System.out.println( "x = " + Integer.toString(x) + "y = " +
		// Integer.toString(y) );

		int xx = (x - 1) >= 0 ? x - 1 : 0;
		for (; xx < x + 2 && xx < _xNum; xx++) {
			int yy = (y - 1) >= 0 ? y - 1 : 0;
			for (; yy < y + 2 && yy < _yNum; yy++) {
				// ha a tavolsag a ket elem kozott egysegnyi (ne lehessen
				// atlosan)
				if (Math.pow(yy - y, 2) + Math.pow(xx - x, 2) == 1) {
					// ha lehetseges a mozgatas
					if (_table[xx][yy] == null) {
						Item tmp = _table[x][y];
						_table[x][y] = _table[xx][yy];
						_table[xx][yy] = tmp;
						
						return true;
					}
				}
			}
		}
		return false;
	}

	/**
	 * Megvizsgalja, hogy a kep ki van-e rakva es annak megfeleloen ter vissza.
	 **/
	public boolean isGameOver() {
		boolean ret = true;
		for (int xx = 0; xx < _xNum; xx++) {
			for (int yy = 0; yy < _yNum; yy++) {
				if (_table[xx][yy] != null) {
					ret = ret && _table[xx][yy].isInGoodPlace(xx, yy);
				}
			}
		}
		// ha kirakta, akkor jelezzuk, hogy vege a jateknak.
		if (ret == true) {
			_inProgress = false;
		}
		return ret;
	}
}
